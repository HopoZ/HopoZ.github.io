<!DOCTYPE html><html lang="zh"><style>body{font-family:"Times New Roman",Helvetica,Tahoma,Arial,LXGW WenKai notoserifsc-medium,"Microsoft YaHei","Hiragino Sans GB","WenQuanYi Micro Hei",sans-serif!important}</style><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" name="viewport"><meta name="description" content="软件开发"><meta name="hexo-theme-A4" content="v2.0.0"><link rel="alternate icon" type="image/webp" href="/images/author-face.jpg"><title>HopoZ</title><link rel="stylesheet" href="/css/highlight/style1.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/markdown.css"><link rel="stylesheet" href="/css/fonts.css"><link rel="stylesheet" href="/css/ui.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/returnToTop.css"><link rel="stylesheet" href="/css/unicons.css"><link rel="stylesheet" href="/css/toc.css"><link rel="stylesheet" href="/css/returnToLastPage.css"><link rel="stylesheet" href="/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="HopoZ" type="application/atom+xml">
</head><style>.index-main{max-width:1200px}</style><style>.paper-main{max-width:1200px}</style><style>.archive-main a:hover{text-decoration:none}</style><style>:root{--waline-theme-color:#323e74;--waline-color:#323e74;--waline-border-color:#323e74;--waline-white:#323e74;--waline-bgcolor-light:#f2fafc}body{color:#323e74;background:#eaeae8}.post-md code{background:#e7f7f3;color:#7f688d}.post-md .highlight,.post-md pre{background:#e7f7f3;color:#7f688d}pre .header,pre .inheritance,pre .ruby .symbol,pre .string,pre .value,pre .xml .cdata{color:#323e74}pre .built_in,pre .constant,pre .literal,pre .number,pre .params,pre .preprocessor{color:#323e74}.year-font-color{color:#323e74!important}.wl-card span.wl-nick{color:#323e74}.wl-card .wl-badge{border:1px solid #323e74;color:#323e74}.wl-btn{border:1px solid #323e74;color:#323e74}.wl-btn.primary{color:#f2fafc}.wl-header label{color:#323e74}a{color:#7f688d}.post-md a{color:#7f688d}.nav li a{color:#7f688d}.archive-main a:link{color:#7f688d}.archive-main a:visited{color:#767c7c}.archive li span{color:#323e74}.post-main-title{color:#323e74}.post-md h1,.post-md h2,.post-md h3,.post-md h4,.post-md h5,.post-md h6{color:#323e74}[data-waline] p{color:#323e74}[data-waline] a{color:#323e74}.wl-sort li.active{color:#323e74}.wl-card .wl-meta>span{background:#f2fafc}.paper{background:#eaeae8}.index-main{background:#f2fafc}.paper-main{background:#f2fafc}.wl-panel{background:#f2fafc}.archive li:nth-child(odd){background:#f2fafc}.archive li:nth-child(even){background:#f2fafc}.post-md table tr:nth-child(odd) td{background:#f2fafc}.post-md table tr:nth-child(even) td{background:#f2fafc}.progress-wrap::after{color:#323e74}.progress-wrap svg.progress-circle path{stroke:#323e74}.progress-wrap::before{background-image:linear-gradient(298deg,#7f688d,#7f688d)}.return-to-last-progress-wrap::after{color:#323e74}.return-to-last-progress-wrap svg.progress-circle path{stroke:#323e74}.return-to-last-progress-wrap::before{background-image:linear-gradient(298deg,#7f688d,#7f688d)}.left-toc-container::-webkit-scrollbar-thumb{background-color:#323e74}.bs-docs-sidebar .nav>.active>a,.bs-docs-sidebar .nav>li>a:focus,.bs-docs-sidebar .nav>li>a:hover{color:#7f688d;border-left-color:#7f688d}.bs-docs-sidebar .nav>li>a{color:#323e74}</style><body><script src="/js/darkmode-js.min.js"></script><script>const options={bottom:"40px",right:"unset",left:"42px",time:"0.3s",mixColor:"#fff",backgroundColor:" #eaeae8  ",buttonColorDark:"#100f2c",buttonColorLight:"#fff",saveInCookies:!0,label:"🌓",autoMatchOsTheme:!0},darkmode=new Darkmode(options);darkmode.showWidget()</script><div class="left-toc-container"><nav id="toc" class="bs-docs-sidebar"></nav></div><div class="paper"><div class="shadow-drop-2-bottom paper-main"><div class="header"><div class="header-container"><style>.header-img{width:56px;height:auto;object-fit:cover;transition:transform .3s ease-in-out;border-radius:50%}.header-img:hover{animation:rotateAnimation 2s linear infinite}@keyframes rotateAnimation{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style><img alt="^-^" cache-control="max-age=86400" class="header-img" src="/images/author-face.jpg"><div class="header-content"><a class="logo" href="/">HopoZ</a> <span class="description">IT狂人|酒中仙</span></div></div><ul class="nav"><li><a href="/">首页</a></li><li><a href="/list/">文章</a></li><li><a href="/about/">关于</a></li><li><a href="/tags/">📌标签</a></li><li><a href="/categories/">🔖所有分类</a></li><li><a href="/categories/daily/">每日</a></li><li><a href="/tags/java/">Java</a></li><li><a href="/categories/algo/">算法</a></li></ul></div><div class="post-main"><div class="post-main-title" style="text-align:center">软件开发</div><div class="post-head-meta-center"><span>最近更新：2025-04-09</span> &nbsp; | &nbsp; <span>字数总计：4.2k</span> &nbsp; | &nbsp; <span>阅读估时：16分钟</span> &nbsp; | &nbsp; <span id="busuanzi_container_page_pv">阅读量：<span id="busuanzi_value_page_pv"></span>次</span></div><div class="post-md"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="post-toc-text">软件架构</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80"><span class="post-toc-text">代码基础</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="post-toc-text">测试</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="post-toc-text">构造过程</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Team-Version-Control"><span class="post-toc-text">Team Version Control</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#OOP%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">OOP的基本概念</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Specifacations"><span class="post-toc-text">Specifacations</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Designing-Specifications"><span class="post-toc-text">Designing Specifications</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Avoiding-Debugging"><span class="post-toc-text">Avoiding Debugging</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Mutability-Immutability"><span class="post-toc-text">Mutability&amp;Immutability</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Recursion"><span class="post-toc-text">Recursion</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Debugging"><span class="post-toc-text">Debugging</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Abstract-Data-Type"><span class="post-toc-text">Abstract Data Type</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Design-Patterns"><span class="post-toc-text">Design Patterns</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Abstract-Functions-Representation-Invariants-AF-RI"><span class="post-toc-text">Abstract Functions &amp; Representation Invariants(AF &amp;RI)</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Interfaces"><span class="post-toc-text">Interfaces</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Equality"><span class="post-toc-text">Equality</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Recursive-Data-Types"><span class="post-toc-text">Recursive Data Types</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Regular-Expression-Grammars"><span class="post-toc-text">Regular Expression &amp; Grammars</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Parser-Generators"><span class="post-toc-text">Parser Generators</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Concurrency"><span class="post-toc-text">Concurrency</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Thread-Safety"><span class="post-toc-text">Thread Safety</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Socket-Networking"><span class="post-toc-text">Socket &amp; Networking</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Queues-Message-Passing"><span class="post-toc-text">Queues &amp; Message-Passing</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Locks-Synchronization"><span class="post-toc-text">Locks &amp; Synchronization</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Graphical-User-Interfaces"><span class="post-toc-text">Graphical User Interfaces</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Map-Filter-Reduce"><span class="post-toc-text">Map,Filter,Reduce</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Little-Languages"><span class="post-toc-text">Little Languages</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="post-toc-text">软件架构与中间件</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">需求分析与系统设计</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="post-toc-text">软件过程与项目管理</span></a></li></ol><div class=".article-gallery"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/hint.css/2.7.0/hint.min.css"><h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><p>构造过程类型：</p><ul><li>自顶向下 top-down</li><li>自底向上 bottom-up</li><li>迭代式 Iterative</li><li>增量式 Incremental</li><li>模块化 Modular</li></ul><p>设计模式类型：</p><ul><li>创建型 Creational</li><li>结构型 Structural</li><li>行为型 Behavioral</li><li>并发型 Concurrency</li></ul><h1 id="代码基础"><a href="#代码基础" class="headerlink" title="代码基础 "></a><font color="#0000dd">代码基础</font> <a id="Judy"></a></h1><p><a id="Judy">由功能偏向质量，由具体偏向抽象，由编程偏向工程，由手工偏向工具</a></p><a id="Judy"><ol><li>Design Goals 编程的视野</li><li>Design Principles 编程的标尺</li><li>Design Patterns 编程的经验</li></ol></a><p><a id="Judy"></a><a href="">三维度八视图</a><br><code>阶段</code>构造时build-time / 运行时视图run-time<br><code>动态性</code>时刻moment / 阶段视图period<br><code>构造对象</code>代码code / 构件视图component<br><a href="/images/Snipaste_2023-05-10_00-15-02.png" class="gallery-item" style="box-shadow:none"><img src="/images/Snipaste_2023-05-10_00-15-02.png"></a><br><a href="">Build-time 构建阶段</a> idea<code>-&gt;</code>requirement<code>-&gt;</code>design<code>-&gt;</code>code<code>-&gt;</code>installable/executable package<br>$$ 代码的逻辑组织\left{<br>\begin{array}{lcl}<br>functions\<br>classes\<br>methods\<br>interfaces<br>\end{array} \right.$$</p><ul><li>Software = Program(codes)</li><li>Software = Algorithm+Data Structure</li><li>Software = Program+Data+Documents</li><li>Software = Modules(Components)+Data/Control Flows</li></ul><p><a href="">链接</a></p><ul><li><code>静态链接</code> 库被copy进代码形成整体，执行的时候无需提供库文件</li><li><code>动态链接</code> 仅仅做出标记，运行时根据标记加载库文件至内存</li></ul><p><a href="">SCI </a><code>Software Connfiguration Item</code>软件配置项<br><a href="">Evolution Graph</a> 演化图<br><a href="">versioning</a><code>版本号的一般命名</code> major.minor.patch</p><p><font color="#dd0000">几种代码运行方式</font><br><a href="">full program interpretation</a> 由runtime system完全载入并interpret<br><a href="">native machine code</a> 完全转换为CPU的可执行程序<br><a href="">Interpreted byte codes</a> 被编译成字节码的形式(如java的class文件)再以前两种方式运行<br><a href="">Perl or Python</a> 在运行时编译成字节码解释执行</p><p><a href="">snapshot diagram</a> 描述程序运行时，某时刻内存里变量层面的状态<br><a href="">memory dump</a> 内存信息转储，储存程序间断错误或信号</p><p><a href="">execution tracing</a> 用日志方法记录程序执行的调用次序<br><a href="">event logging</a> (系统层次)抽象的行为和错误日志</p><p><a href="">external quality factor</a></p><ol><li><font color="#dd0000">Correctness 按照预先定义的”规约”执行</font><ul><li>Testing and Debugging</li><li>Defensive programming</li><li>Formal approach(高级)</li></ul></li><li><font color="#dd0000">Robustness 针对异常情况的处理(Exception handling)</font><blockquote><p>合称reliability</p></blockquote></li><li><font color="#dd0000">Extendibility 对规约修改的容易程度(高内聚，低耦合，如下)</font><ul><li>Design simplicity简约主义</li><li>Decentralization分离主义</li></ul></li><li><font color="#dd0000">Reusability 一次开发，多次使用</font><blockquote><p>合称modularity</p></blockquote></li><li>Compatibility 不同软件间的相互可容易的集成<ul><li>关键是in homogeneity of design, standardization; 尤其是standard protocols</li></ul></li><li>Efficiency 在硬件资源上放尽可能少的demands(processor time, space, bandwidth)</li><li>Portability 软件在不同的软硬件环境间移植</li><li>Ease of use 容易use, installation, operation, monitoring<ul><li>Structural Simplicity</li><li>Know the user</li></ul></li><li>Functionality</li><li>Timeliness 按时release</li></ol><p><a href="">Liskov Substitution Principle</a><code>LSP原则</code> 如果S是T的子类型<code>subtype</code>，那么程序中使用T类型的对象的地方，也可以用S类型的对象替换，而不会产生任何错误或异常。</p><p><a href="">委托</a><code>delegation</code>是一种设计模式，用于将某个对象的功能委托给另一个对象来处理。它通过在对象之间建立一种关系，使得一个对象能够调用另一个对象的方法，并将任务的执行委托给该对象。</p><p><a href="">协变</a><code>Covariance</code>：<br>协变是指在类型转换或继承关系中，保持类型关系的方向不变。简而言之，如果类型 A 可以被隐式转换为类型 B，那么 A 是 B 的协变类型。</p><p><a href="">Composite Reuse Principle (CRP)</a> 更倾向于使用委派而不是继承来实现复用。</p><p><a href="">SOLID</a>是OO设计原则 5 classes design principles<br>▪ (SRP) The Single Responsibility Principle 单一责任原则：There should never be more than one reason for a class to change<br>▪ (OCP) The Open-Closed Principle 开放-封闭原则:行为是可拓展的，自身代码是不可修改的<br>▪ (LSP) The Liskov Substitution Principle Liskov替换原则：子类型可替换父类型<br>▪ (DIP) The Dependency Inversion Principle 依赖转置原则：具体应该依赖于抽象<br>▪ (ISP) The Interface Segregation Principle 接口聚合原则：只提供必须的接口</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><font color="#0000dd">测试</font></h1><p><a href="">internal quality factor</a></p><ol><li>LOC<code>代码行数</code></li><li>Cyclomatic complexity<code>循环层次</code></li><li>coupling and cohesion<code>耦合度和内聚性</code></li><li>readability<code>可读性</code></li></ol><p><a href="">Test first programming</a> 先写测试，再写代码<br><a href="">residual defect rates per kloc</a> 每千行代码残留缺陷率<br><code>Unit Testing</code>单元测试<br><code>Integration testing</code>集成测试<br><code>System testing</code>系统测试<br><a href="">黑盒测试</a> 从spec导出测试区间的等价类划分<br><a href="">白盒测试</a> 考虑内部实现细节，对所有执行路径进行等价类划分找出代表性的简单路径</p><p><a href="">code coverage</a> 代码覆盖度</p><ol><li>Function Coverage</li><li>Statement Coverage</li><li>Branch Coverage</li><li>Condition Coverage</li><li>Path Coverage</li></ol><h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a><font color="#0000dd">构造过程</font></h1><p>$$ \textcolor{red}{basic\ types} \left{<br>\begin{array}{lcl}<br>Linear\<br>Iterative\<br>\end{array} \right.$$</p><p>$$ \textcolor{red}{existing\ models}\left{<br>\begin{array}{lcl}<br>Waterfall\ 瀑布\<br>Incremental\ 增量\<br>V-Model\ V字\<br>Prototyping\ 原型\<br>Spiral\ 螺旋<br>\end{array} \right.$$<br><a href="">Waterfall</a> 线性推进，阶段划分清楚<br><a href="">Increment</a> 多个Waterfall的串行<br><a href="">V-Model</a> Waterfall变型，强调测试的重要性<br><a href="">W-Model</a> 由两个V组成，增加了Verification和Validation,<br><a href="">Prototyping</a> 首先做出合适的基础模型，接着不断根据需求迭代 抛弃式和演化式<br><a href="">Spiral</a> 风险驱动，多轮迭代基本遵循Waterfall<br><a href="">Agile development 敏捷开发</a> rapid delivery,eXtreme Programming<br><a href="">Pair Programming</a> 一个人写，一个人看<br><a href="">Scrum</a> 核心是 Sprint（迭代）和 Scrum Team（团队）<br><a href="">Fagan inspection</a> 核心思想是通过系统性的检查和评审来提高软件质量。</p><h1 id="Team-Version-Control"><a href="#Team-Version-Control" class="headerlink" title="Team Version Control"></a><font color="#0000dd">Team Version Control</font></h1><p><a href="">Software Configuration Item</a> 软件中发生变化的基本单元</p><h1 id="OOP的基本概念"><a href="#OOP的基本概念" class="headerlink" title="OOP的基本概念"></a><font color="#0000dd">OOP的基本概念</font></h1><p><code>public</code>,<code>protected</code>,<code>default</code>,<code>private</code>四种对象访问权限类型<br><a href="">抽象类</a> 包含至少一个抽象方法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class name{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="">多态</a></p><ol><li><font color="red">Ad-hoc polymorphism</font><code>重载多态 / 运算符多态</code> 函数重载或运算符重载</li><li><font color="red">Parametric polymorphism</font><code>泛型多态 / 参数化多态</code> 泛型</li><li><font color="red">subtyping(subytpe polymorphism or inclusion polymorphism)</font><code>对象多态/继承多态</code> 继承和方法重写</li></ol><h1 id="Specifacations"><a href="#Specifacations" class="headerlink" title="Specifacations"></a><font color="#0000dd">Specifacations</font></h1><p><a href="">Spec</a><code>规约</code>充当过程的实现者与其客户之间的重要防火墙。它使单独开发成为可能：客户可以自由编写使用该过程的代码而无需查看其源代码，而实现者可以自由编写实现该过程的代码而不知道它将如何使用。</p><p><code>Null</code> 值是 Java 类型系统中的一个不幸漏洞。当程序试图在null上调用方法或访问其成员时，会触发NullPointerException（空指针异常）</p><p><a href="">precondition</a><code>前提条件</code>说明参数的限制等，<a href="">postcondition</a><code>后置条件</code>说明返回类型等<br><a href="">java异常</a></p><p>$$ \left{<br>\begin{array}{lcl}<br>checked\ exception\<br>unchecked\ exception (RuntimeException)<br>\end{array}<br>\right.$$<br><code>try,catch,finally</code><br><a href="/images/Snipaste_2023-05-16_09-36-58.png" class="gallery-item" style="box-shadow:none"><img src="/images/Snipaste_2023-05-16_09-36-58.png"></a></p><blockquote><p>Error表示严重的错误,一般是由于虚拟机出现问题或系统资源耗尽等无法恢复的情况引起的。通常情况下，程序不会捕获和处理Error类型的异常，而是由虚拟机来处理。<br>Exception表示非致命的异常，可以通过程序的处理来恢复或终止程序的执行。</p></blockquote><h1 id="Designing-Specifications"><a href="#Designing-Specifications" class="headerlink" title="Designing Specifications"></a><font color="#0000dd">Designing Specifications</font></h1><p>$$ \left{\begin{array}{lcl}<br>deterministic和undetdetermined(不是nondeterministic)\<br>declarative和operational\<br>strong(precondition弱，postcondition强)和weak<br>\end{array}\right.$$<br>要求:coherent<code>meaning that it does one thing and does it well</code>,<br>results informative,<br>strong enough,<br>weak enouph,<br>use abstract types when possible<br><code>static</code> vs. <code>instance</code><br><a href="">static</a><br>static关键字用于声明静态成员（变量或方法），即类级别的成员，不依赖于类的实例而存在。<br>静态成员属于类本身，只会在内存中存在一份副本，被所有类的实例共享。<br>可以通过类名直接访问静态成员，无需创建类的实例。<br>静态变量在程序启动时被初始化，可以在任何时候访问。<br><a href="">instance</a><br>实例成员是与类的实例相关联的成员，每个类实例都有自己的一组实例成员。<br>实例成员包括实例变量和实例方法，它们依赖于类的实例的创建和存在。<br>实例成员在每个类的实例中都有自己的副本，它们独立于其他实例。<br>实例成员需要通过创建类的实例来访问和使用。</p><h1 id="Avoiding-Debugging"><a href="#Avoiding-Debugging" class="headerlink" title="Avoiding Debugging"></a><font color="#0000dd">Avoiding Debugging</font></h1><p>利用<code>assert</code>检查先决条件是<code>防御性编程</code>的一个例子。<br>不要使用断言来测试程序外部的条件，而是使用异常。<br>由于断言可能被禁用，您的程序的正确性不应该依赖于断言表达式是否被执行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (x &gt;= 0) : "x is " + x;</span><br></pre></td></tr></tbody></table></figure><p>当x是-1时，将输出x is -1<br>默认情况断言语句不执行，必须通过将-ea（代表启用断言）传递给 Java 虚拟机来显式启用断言。</p><h1 id="Mutability-Immutability"><a href="#Mutability-Immutability" class="headerlink" title="Mutability&amp;Immutability"></a><font color="#0000dd">Mutability&amp;Immutability</font></h1><p>mutabale objects会使对其大量操作时所需空间复杂度大大降低<br>passing mutable objects和returning mutable objects一样有latent bug,需要defensive copying<br>Sharing a mutable object complicates a contract. 因为要用时合同不清楚的话不知道是否已经被人修改</p><blockquote><p>contract: a form of agreement or protocol that establishes the rules of engagement between different parts of a system</p></blockquote><h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a><font color="#0000dd">Recursion</font></h1><p>base case + recursive step</p><h1 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a><font color="#0000dd">Debugging</font></h1><p>reproduce the bug <code>-&gt;</code> find the bug <code>-&gt;</code> fix the bug</p><h1 id="Abstract-Data-Type"><a href="#Abstract-Data-Type" class="headerlink" title="Abstract Data Type"></a><font color="#0000dd">Abstract Data Type</font></h1><p>operation分类:</p><ol><li>creator： create new objects of the type. <code>t* → T</code></li><li>producer： create new objects from old objects of the type. <code>T+, t* → T</code></li><li>observer： take objects of the abstract type and return objects of a different type. <code>T+, t* → t</code></li><li>mutator: change objects. <code>T+, t* → void | t | T</code><blockquote><p>Each T is the abstract type itself; each t is some other type. The + marker indicates that the type may occur one or more times in that part of the signature, and the * marker indicates that it occurs zero or more times. | indicates or.</p></blockquote></li></ol><p>抽象(高层思维)、模块化、封装、细节隐藏、单元化(separation of concerns)<br><a href="">representation independent</a><code>表示独立性</code> 核心思想是将数据的表示方式与其处理方法相分离.<br><a href="">override</a><code>覆盖</code>，可把基类中标记为<code>abstract</code>的函数覆盖重写<br><a href="">overload</a><code>重载</code>,构造函数名相同但参数列表不同的方法，以实现静态多态性</p><h1 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a><font color="#0000dd">Design Patterns</font></h1><p>▪ <code>Creational patterns</code> 创建型模式<br>– Concern the process of object creation<br>▪ <code>Structural patterns</code> 结构型模式<br>– Deal with the composition of classes or objects<br>▪ <code>Behavioral patterns</code> 行为类模式<br>– Characterize the ways in which classes or objects interact and distribute responsibility.<br><a href="">factory method</a><code>Virtual Constructor/工厂模型</code> A creator implemented as a static method<br><a href="">Adapter</a><code>适配器模式</code><br><a href="">Decorator</a><code>装饰器模式</code> 对每一个特性构造子类，通过委派机制增加到对象上<br><a href="">Strategy</a><code>策略模式</code> 有多种不同的算法来实现同一个任务，但需要client根据需要动态切换算法，而不是写死在代码里<br><a href="">Template Method</a><code>模板模式</code> 共性的步骤在抽象类内公共实现，差异化的步骤在各个子类中实现<br><a href="">Iterator</a> A strategy pattern for iteration<br><a href="">visitor</a> 为ADT预留一个将来可扩展功能的“接入点”，外部实现的功能代码可以在不改变ADT本身的情况下通过delegation接入ADT</p><h1 id="Abstract-Functions-Representation-Invariants-AF-RI"><a href="#Abstract-Functions-Representation-Invariants-AF-RI" class="headerlink" title="Abstract Functions &amp; Representation Invariants(AF &amp;RI)"></a><font color="#0000dd">Abstract Functions &amp; Representation Invariants(AF &amp;RI)</font></h1><p><code>抽象函数</code>定义了系统的功能接口，使得模块之间可以进行交互和协作；而<code>表示不变量</code>则确保数据结构的有效性和一致性，提供了正确和可靠的操作。</p><h1 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a><font color="#0000dd">Interfaces</font></h1><p>Java 的<code>接口</code>是一种用于表达抽象数据类型的有用语言机制<code>Language mechanism</code>。<br><code>subtypes</code>子类型 “B is a subtype of A” means “every B is an A.” In terms of specifications: “every B satisfies the specification for A.”</p><h1 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a><font color="#0000dd">Equality</font></h1><p>The <code>==</code> operator compares references. More precisely, it tests <code>referential equality</code>. Two references are == if they point to the same storage in memory.<br>The <code>equals()</code> operation compares object contents – in other words, <code>object equality</code>, in the sense that we’ve been talking about in this reading.<br>The <code>instanceof</code> operator tests whether an object is an instance of a particular type.<br>Always override <code>hashCode</code> when you override <code>equals</code>.<br>immutable types must override both equals() and hashCode().</p><h1 id="Recursive-Data-Types"><a href="#Recursive-Data-Types" class="headerlink" title="Recursive Data Types"></a><font color="#0000dd">Recursive Data Types</font></h1><p>递归数据类型</p><h1 id="Regular-Expression-Grammars"><a href="#Regular-Expression-Grammars" class="headerlink" title="Regular Expression &amp; Grammars"></a><font color="#0000dd">Regular Expression &amp; Grammars</font></h1><p><code>形式语言和自动机</code>讲过原理，java实现的语法没讲过<br><code>级联</code><br><code>x ::= y z</code><br>an x is a y followed by a z</p><p><code>重复</code><br><code>x ::= y*</code><br>an x is zero or more y</p><p><code>联合(也称为交替)</code><br><code>x ::= y | z</code><br>an x is a y or a z</p><h1 id="Parser-Generators"><a href="#Parser-Generators" class="headerlink" title="Parser Generators"></a><font color="#0000dd">Parser Generators</font></h1><p>解析器生成器（Parser Generator）是一种工具，用于根据给定的文法规则和语法描述生成解析器代码。解析器的作用是将输入的文本按照语法规则进行分析，将其转换为抽象语法树或执行特定的操作。</p><h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a><font color="#0000dd">Concurrency</font></h1><p>即<code>并发</code>,多个计算同时运行,共享内存和消息传递范例<br><code>进程</code>就像一台虚拟计算机；<code>线程</code>就像一个虚拟处理器</p><h1 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread Safety"></a><font color="#0000dd">Thread Safety</font></h1><ol><li>限制：不共享数据。</li><li>不变性：共享，但保持数据不可变。</li><li>线程安全数据类型：将共享可变数据存储在单个线程安全数据类型中。</li></ol><h1 id="Socket-Networking"><a href="#Socket-Networking" class="headerlink" title="Socket &amp; Networking"></a><font color="#0000dd">Socket &amp; Networking</font></h1><p><code>Socket（套接字）</code>是计算机网络编程中用于实现网络通信的一种编程接口。它提供了一种机制，使得不同计算机之间的进程能够通过网络进行数据交换和通信。<br>Socket在网络通信中的作用类似于电话中的插座。</p><ol><li><p><code>TCP套接字（Transmission Control Protocol）</code>：TCP套接字提供可靠的、面向连接的通信。它使用TCP协议来确保数据的可靠传输，通过三次握手建立连接，并提供流式的、双向的通信。TCP套接字适用于需要可靠传输和顺序传输的应用，如文件传输、网页浏览等。</p></li><li><p><code>UDP套接字（User Datagram Protocol）</code>：UDP套接字提供无连接的、不可靠的通信。它使用UDP协议来发送和接收数据，不保证数据的可靠性和顺序，但具有较低的延迟。UDP套接字适用于实时通信和广播等应用，如视频传输、游戏、DNS等。</p></li></ol><h1 id="Queues-Message-Passing"><a href="#Queues-Message-Passing" class="headerlink" title="Queues &amp; Message-Passing"></a><font color="#0000dd">Queues &amp; Message-Passing</font></h1><p>使用队列来实现消息传递</p><h1 id="Locks-Synchronization"><a href="#Locks-Synchronization" class="headerlink" title="Locks &amp; Synchronization"></a><font color="#0000dd">Locks &amp; Synchronization</font></h1><p><code>Locks（锁）</code>和<code>Synchronization（同步）</code>是在并发编程中用于管理共享资源和保护临界区的重要概念和技术。<br><code>锁</code>是一种机制，用于控制对共享资源的访问。它提供了对临界区的互斥访问，确保在同一时间只有一个线程可以进入临界区并执行操作，从而避免多个线程同时访问共享资源而导致的数据不一致或竞态条件问题。常见的锁包括<code>互斥锁（Mutex Lock）</code>和<code>读写锁（Read-Write Lock）</code>等。<br><code>同步</code>是一种机制，用于协调多个线程的执行顺序，以确保数据的一致性和正确性。它通过使用锁和其他同步原语（如<code>条件变量</code>、<code>信号量</code>等）来控制线程的执行顺序和访问共享资源的方式。同步机制可以防止多个线程之间的竞争条件和数据竞争问题，并确保线程之间的操作按照预期的顺序执行。</p><h1 id="Graphical-User-Interfaces"><a href="#Graphical-User-Interfaces" class="headerlink" title="Graphical User Interfaces"></a><font color="#0000dd">Graphical User Interfaces</font></h1><ol><li><p><code>窗口（Window）</code>：窗口是 GUI 的基本容器，用于承载其他组件。每个窗口都有自己的标题栏、边框和控制按钮，可以最大化、最小化、关闭等。</p></li><li><p><code>控件（Widget）</code>：控件是 GUI 中的可视化元素，用于展示信息、接受用户输入和执行操作。常见的控件包括按钮、文本框、标签、复选框、滚动条等。</p></li><li><p><code>布局管理器（Layout Manager）</code>：布局管理器用于控制和安排窗口中的控件的位置和大小。它可以确保控件在窗口中正确布局，并根据窗口的大小进行自适应调整。</p></li><li><p><code>事件处理（Event Handling）</code>：GUI 界面可以响应用户的输入事件，如点击按钮、拖动滚动条等。事件处理机制用于捕获和处理这些事件，并触发相应的操作和逻辑。</p></li></ol><h1 id="Map-Filter-Reduce"><a href="#Map-Filter-Reduce" class="headerlink" title="Map,Filter,Reduce"></a><font color="#0000dd">Map,Filter,Reduce</font></h1><ol><li><p><code>映射（Mapping）</code>：<br>映射操作是将集合或序列中的每个元素都应用一个函数，生成一个新的集合或序列，其中每个元素都是原始元素经过函数处理后得到的结果。简单来说，就是对集合中的每个元素进行转换或映射。常见的应用场景包括对列表中的每个元素进行加工、提取元素的某个属性等。</p></li><li><p><code>过滤（Filtering）</code>：<br>过滤操作是基于某个条件，从集合或序列中选择满足条件的元素，生成一个新的集合或序列。过滤操作通过提供一个判定条件函数来决定哪些元素应该被保留下来，而哪些应该被过滤掉。常见的应用场景包括从列表中筛选出符合特定条件的元素。</p></li><li><p><code>归约（Reducing）</code>：<br>归约操作是将一个集合或序列中的所有元素通过某个操作进行组合，生成一个单一的结果。这个操作通常是将集合中的元素逐个进行累积或聚合，以产生一个最终结果。常见的归约操作有求和、求最大值、求平均值等。</p></li></ol><h1 id="Little-Languages"><a href="#Little-Languages" class="headerlink" title="Little Languages"></a><font color="#0000dd">Little Languages</font></h1><p><code>小语言</code>通常用于描述和处理特定领域的数据和操作。它们可以用于<code>数据转换</code>、<code>配置文件解析</code>、<code>模板生成</code>、领<code>域特定的查询</code>和<code>规则引擎</code>等任务。<br>一些常见的小语言包括<code>正则表达式语言</code>、<code>SQL(结构化查询语言用于数据库查询)</code>、<code>HTML（超文本标记语言）</code></p><h1 id="软件架构与中间件"><a href="#软件架构与中间件" class="headerlink" title="软件架构与中间件"></a>软件架构与中间件</h1><h1 id="需求分析与系统设计"><a href="#需求分析与系统设计" class="headerlink" title="需求分析与系统设计"></a>需求分析与系统设计</h1><h1 id="软件过程与项目管理"><a href="#软件过程与项目管理" class="headerlink" title="软件过程与项目管理"></a>软件过程与项目管理</h1></div></div><div class="post-meta"><i><span>2024-01-20</span> <span>该篇文章被 HopoZ</span> <span>打上标签: <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/">软件开发 </a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/">软件架构 </a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/">软件构造 </a></span><span>归为分类: <a href="/categories/base/">base</a></span></i></div><br><div class="post-footer-pre-next"><span>prev：<a href="/%E8%AE%A1%E7%BB%84/">计算机组成原理</a></span> <span class="post-footer-pre-next-last-span-right">next：<a href="/nand2tetris/">nand2tetris</a></span></div></div><div class="footer"><span>© 2025 HopoZ / <a href="/friends/">友链 </a>/ <a href="/contact/">联系 </a>/ <a href="/support/">支持</a></span></div><div class="footer-last"><span>吃人的历史</span></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript"></script><script src="/js/toc.js"></script><script src="/js/randomHeaderContent.js"></script><script src="/js/returnToTop.js"></script><script src="/js/returnToLastPage.js"></script><script src="/js/lightgallery/lightgallery.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-autoplay.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-zoom.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-rotate.umd.min.js"></script><script src="/js/lightgallery/plugins/lg-paper.umd.min.js"></script><script type="text/javascript">if("undefined"!=typeof lightGallery){var options1={selector:".gallery-item",plugins:[lgThumbnail,lgFullscreen,lgAutoplay,lgZoom,lgRotate,lgPager],thumbnail:!0,zoom:!0,rotate:!0,autoplay:!0,fullScreen:!0,pager:!0,zoomFromOrigin:!0,actualSize:!0,enableZoomAfter:300};lightGallery(document.getElementsByClassName(".article-gallery")[0],options1)}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="progress-wrap shadow-drop-2-bottom"><svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102"><path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/></svg></div><div class="return-to-last-progress-wrap shadow-drop-2-bottom"><svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102"><path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/></svg></div></div></body></html><script src="/js/emojiHandler.js"></script><script>document.addEventListener("DOMContentLoaded",()=>{wrapEmojis(".paper")})</script>